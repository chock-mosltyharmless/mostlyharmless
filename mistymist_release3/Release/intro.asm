; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\Joachim Hofer\Documents\mostlyharmless\mistymist_release3\i4k_OGL\src\intro.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@JAEIBBBF@glTexImage3D?$AA@		; `string'
PUBLIC	??_C@_0N@ICBDHBI@glUseProgram?$AA@		; `string'
PUBLIC	??_C@_0O@PIOEEBPO@glLinkProgram?$AA@		; `string'
PUBLIC	??_C@_0P@LDMLEABL@glAttachShader?$AA@		; `string'
PUBLIC	??_C@_0BA@DGIEGONF@glCompileShader?$AA@		; `string'
PUBLIC	??_C@_0P@DFHCPFMO@glShaderSource?$AA@		; `string'
PUBLIC	??_C@_0BA@FLKLHNKP@glCreateProgram?$AA@		; `string'
PUBLIC	??_C@_0P@HGHBNC@glCreateShader?$AA@		; `string'
PUBLIC	??_C@_0HF@NDFDEMFF@varying?5vec3?5o?$DLvarying?5mat4?5p?$DLvo@ ; `string'
PUBLIC	??_C@_0MD@NABIFNKE@uniform?5sampler2D?5t?$DLvarying?5vec3@ ; `string'
PUBLIC	??_C@_0EHG@KNMKDGNO@uniform?5sampler3D?5t?$DLvarying?5vec3@ ; `string'
PUBLIC	?viewport@@3PAHA				; viewport
PUBLIC	?hWnd@@3PAUHWND__@@A				; hWnd
PUBLIC	?fragmentMainBackground@@3PBDB			; fragmentMainBackground
PUBLIC	?fragmentOffscreenCopy@@3PBDB			; fragmentOffscreenCopy
PUBLIC	?vertexMainObject@@3PBDB			; vertexMainObject
_BSS	SEGMENT
?viewport@@3PAHA DD 04H DUP (?)				; viewport
?hWnd@@3PAUHWND__@@A DD 01H DUP (?)			; hWnd
_BSS	ENDS
;	COMDAT ??_C@_0N@JAEIBBBF@glTexImage3D?$AA@
CONST	SEGMENT
??_C@_0N@JAEIBBBF@glTexImage3D?$AA@ DB 'glTexImage3D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ICBDHBI@glUseProgram?$AA@
CONST	SEGMENT
??_C@_0N@ICBDHBI@glUseProgram?$AA@ DB 'glUseProgram', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PIOEEBPO@glLinkProgram?$AA@
CONST	SEGMENT
??_C@_0O@PIOEEBPO@glLinkProgram?$AA@ DB 'glLinkProgram', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LDMLEABL@glAttachShader?$AA@
CONST	SEGMENT
??_C@_0P@LDMLEABL@glAttachShader?$AA@ DB 'glAttachShader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DGIEGONF@glCompileShader?$AA@
CONST	SEGMENT
??_C@_0BA@DGIEGONF@glCompileShader?$AA@ DB 'glCompileShader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DFHCPFMO@glShaderSource?$AA@
CONST	SEGMENT
??_C@_0P@DFHCPFMO@glShaderSource?$AA@ DB 'glShaderSource', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FLKLHNKP@glCreateProgram?$AA@
CONST	SEGMENT
??_C@_0BA@FLKLHNKP@glCreateProgram?$AA@ DB 'glCreateProgram', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HGHBNC@glCreateShader?$AA@
CONST	SEGMENT
??_C@_0P@HGHBNC@glCreateShader?$AA@ DB 'glCreateShader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@NDFDEMFF@varying?5vec3?5o?$DLvarying?5mat4?5p?$DLvo@
CONST	SEGMENT
??_C@_0HF@NDFDEMFF@varying?5vec3?5o?$DLvarying?5mat4?5p?$DLvo@ DB 'varyin'
	DB	'g vec3 o;varying mat4 p;void main(void){p=gl_ModelViewMatrix;'
	DB	'o=vec3(gl_Vertex.xy,.99);gl_Position=vec4(o,1.);}', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0MD@NABIFNKE@uniform?5sampler2D?5t?$DLvarying?5vec3@
CONST	SEGMENT
??_C@_0MD@NABIFNKE@uniform?5sampler2D?5t?$DLvarying?5vec3@ DB 'uniform sa'
	DB	'mpler2D t;varying vec3 o;varying mat4 p;void main(void){vec2 '
	DB	'n=vec2(fract(sin(dot(o.xy+p[0][0],vec2(12.9898,78.233)))*4375'
	DB	'8.5453));gl_FragColor=texture2D(t,.5*o.xy+.5+.001*n)+n.x*.03;'
	DB	'}', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EHG@KNMKDGNO@uniform?5sampler3D?5t?$DLvarying?5vec3@
CONST	SEGMENT
??_C@_0EHG@KNMKDGNO@uniform?5sampler3D?5t?$DLvarying?5vec3@ DB 'uniform s'
	DB	'ampler3D t;varying vec3 o;varying mat4 p;vec3 e(vec3 s, int i'
	DB	'){float n=1.;s*=2.;vec3 r=vec3(0.);for(;i>0;i--){r+=texture3D'
	DB	'(t,s).xyz*n;n*=0.7;s*=1.93;}return r;}void main(void){vec3 d='
	DB	'normalize(o*vec3(1.,.6,1.));vec3 r=vec3(0.,0.,8.*p[0][1]-8.);'
	DB	'float s=sin(p[0][3]*9.42);float c=cos(p[0][3]*9.42);r.xz=r.xz'
	DB	'*mat2(c,-s,s,c);d.xz=d.xz*mat2(c,-s,s,c);s=sin(p[0][2]*9.42);'
	DB	'c=cos(p[0][2]*9.42);r.yz=r.yz*mat2(c,-s,s,c);d.yz=d.yz*mat2(c'
	DB	',-s,s,c);vec3 l=vec3(0.,0.,0.);float m=0.;vec3 w=vec3(.016,.0'
	DB	'12,.009)*p[1][0];while(length(r)<15.&&m<0.95){float i=min(len'
	DB	'gth(r+vec3(0.,9.,0.))-8.2+20.*p[2][1],max(abs(r.y)-1.1-p[1][3'
	DB	']*20.,abs(length(r.xz)-2.+2.*p[1][2])*(.5+p[2][0])-2.*p[1][2]'
	DB	'+1.2));vec3 n=r;n.y-=p[0][0]*.66;vec3 c=e(n*0.03,2)*.04*p[1]['
	DB	'1];n.y=n.y*(.05+p[1][1])-.5*p[0][0];float v=e(c+n*.08,6).r;i-'
	DB	'=.5*v;l+=w;m+=.003;float t=(1.-m)*clamp(1.-exp(i),0.,1.);floa'
	DB	't f=smoothstep(-2.5,-1.5,-length(r)+v*6.*(p[2][1]+1.));l+=(mi'
	DB	'x(vec3(.7,.2,.0),vec3(.1,.45,.85),f)*clamp(abs(f-.5),-0.5,1.)'
	DB	'+clamp(r.y+v.x-2.*p[1][3]-1.,.0,100.))*t;m+=t;r+=d*max(.02,(i'
	DB	')*.5);}l+=(1.-m)*mix(vec3(.0,.1,.2),vec3(.0,.0,.1),normalize('
	DB	'r).y);gl_FragColor=vec4(l-.3,1.);}', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_sceneLength DB	014H
	DB	04H
	DB	010H
	DB	014H
	DB	014H
	DB	028H
	DB	014H
	DB	014H
	DB	028H
	DB	028H
	DB	014H
	DB	023H
	DB	03cH
	ORG $+3
_sceneData DB	042H
	DB	045H
	DB	032H
	DB	05bH
	DB	039H
	DB	036H
	DB	07fH
	DB	048H
	DB	07fH
	DB	042H
	DB	045H
	DB	032H
	DB	01fH
	DB	061H
	DB	040H
	DB	07fH
	DB	016H
	DB	07fH
	DB	05cH
	DB	01cH
	DB	05dH
	DB	07fH
	DB	063H
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	05fH
	DB	069H
	DB	01bH
	DB	06aH
	DB	05cH
	DB	064H
	DB	0cH
	DB	014H
	DB	07fH
	DB	028H
	DB	059H
	DB	0aH
	DB	06eH
	DB	067H
	DB	05eH
	DB	09H
	DB	00H
	DB	00H
	DB	057H
	DB	044H
	DB	031H
	DB	04bH
	DB	00H
	DB	05cH
	DB	07fH
	DB	07fH
	DB	07fH
	DB	07eH
	DB	065H
	DB	058H
	DB	07cH
	DB	066H
	DB	05eH
	DB	07fH
	DB	00H
	DB	07fH
	DB	07eH
	DB	065H
	DB	058H
	DB	07cH
	DB	066H
	DB	05eH
	DB	07fH
	DB	00H
	DB	07fH
	DB	07fH
	DB	045H
	DB	02dH
	DB	05cH
	DB	045H
	DB	05aH
	DB	07fH
	DB	00H
	DB	07fH
	DB	045H
	DB	019H
	DB	05aH
	DB	039H
	DB	04bH
	DB	072H
	DB	025H
	DB	07H
	DB	07fH
	DB	073H
	DB	040H
	DB	02aH
	DB	07dH
	DB	041H
	DB	058H
	DB	07fH
	DB	00H
	DB	00H
	DB	032H
	DB	028H
	DB	07fH
	DB	07fH
	DB	06eH
	DB	070H
	DB	07fH
	DB	053H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
_sceneDelta DB	00H
	DB	00H
	DB	00H
	DB	0c4H
	DB	028H
	DB	0aH
	DB	00H
	DB	0ceH
	DB	00H
	DB	01aH
	DB	0d7H
	DB	02bH
	DB	060H
	DB	02H
	DB	03fH
	DB	00H
	DB	069H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fbH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01eH
	DB	00H
	DB	01eH
	DB	03cH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	088H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	0e0H
	DB	0d5H
	DB	0e0H
	DB	0dfH
	DB	0fcH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0aH
	DB	04H
	DB	0fbH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	028H
	DB	0ecH
	DB	0abH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
?fragmentMainBackground@@3PBDB DD FLAT:??_C@_0EHG@KNMKDGNO@uniform?5sampler3D?5t?$DLvarying?5vec3@ ; fragmentMainBackground
?fragmentOffscreenCopy@@3PBDB DD FLAT:??_C@_0MD@NABIFNKE@uniform?5sampler2D?5t?$DLvarying?5vec3@ ; fragmentOffscreenCopy
?vertexMainObject@@3PBDB DD FLAT:??_C@_0HF@NDFDEMFF@varying?5vec3?5o?$DLvarying?5mat4?5p?$DLvo@ ; vertexMainObject
_glnames DD	FLAT:??_C@_0P@HGHBNC@glCreateShader?$AA@
	DD	FLAT:??_C@_0BA@FLKLHNKP@glCreateProgram?$AA@
	DD	FLAT:??_C@_0P@DFHCPFMO@glShaderSource?$AA@
	DD	FLAT:??_C@_0BA@DGIEGONF@glCompileShader?$AA@
	DD	FLAT:??_C@_0P@LDMLEABL@glAttachShader?$AA@
	DD	FLAT:??_C@_0O@PIOEEBPO@glLinkProgram?$AA@
	DD	FLAT:??_C@_0N@ICBDHBI@glUseProgram?$AA@
	DD	FLAT:??_C@_0N@JAEIBBBF@glTexImage3D?$AA@
_DATA	ENDS
PUBLIC	_cosf@4
EXTRN	__fltused:DWORD
; Function compile flags: /Ogsp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT _cosf@4
_TEXT	SEGMENT
__X$ = 8						; size = 4
_cosf@4	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR __X$[ebp]
	fcos
	pop	ebp
	ret	4
_cosf@4	ENDP
_TEXT	ENDS
PUBLIC	?cos@@YAMM@Z					; cos
; Function compile flags: /Ogsp
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 512  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR __X$[ebp]
	fcos
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
PUBLIC	__real@47012f00
PUBLIC	__real@46180400
PUBLIC	__real@3f000000
PUBLIC	?intro_init@@YGXXZ				; intro_init
EXTRN	__imp__glTexImage2D@36:PROC
EXTRN	__imp__glTexParameterf@12:PROC
EXTRN	__imp__glTexParameteri@12:PROC
EXTRN	__imp__glBindTexture@8:PROC
EXTRN	__imp__glGenTextures@8:PROC
EXTRN	__imp__glEnable@4:PROC
EXTRN	?frand@@YGMXZ:PROC				; frand
EXTRN	__imp__wglGetProcAddress@4:PROC
_BSS	SEGMENT
_offscreenTexture DD 01H DUP (?)
_noiseTexture DD 01H DUP (?)
_shaderPrograms DD 02H DUP (?)
_noiseData DD	04000H DUP (?)
_glFP	DD	08H DUP (?)
_BSS	ENDS
;	COMDAT __real@47012f00
; File c:\users\joachim hofer\documents\mostlyharmless\mistymist_release3\i4k_ogl\src\intro.cpp
CONST	SEGMENT
__real@47012f00 DD 047012f00r			; 33071
CONST	ENDS
;	COMDAT __real@46180400
CONST	SEGMENT
__real@46180400 DD 046180400r			; 9729
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Ogsp
CONST	ENDS
;	COMDAT ?intro_init@@YGXXZ
_TEXT	SEGMENT
?intro_init@@YGXXZ PROC					; intro_init, COMDAT

; 253  : {

	push	ebx
	push	esi
	push	edi

; 254  : 	// create openGL functions
; 255  : 	for (int i=0; i<NUM_GL_NAMES; i++) glFP[i] = (GenFP)wglGetProcAddress(glnames[i]);

	xor	esi, esi
$LL6@intro_init:
	push	DWORD PTR _glnames[esi]
	call	DWORD PTR __imp__wglGetProcAddress@4
	mov	DWORD PTR _glFP[esi], eax
	add	esi, 4
	cmp	esi, 32					; 00000020H
	jl	SHORT $LL6@intro_init

; 256  : 
; 257  : 	// create noise Texture
; 258  : #ifdef FLOAT_TEXTURE
; 259  : 	for (int i = 0; i < NOISE_TEXTURE_SIZE * NOISE_TEXTURE_SIZE * NOISE_TEXTURE_SIZE * 4; i++)

	mov	esi, OFFSET _noiseData
$LL3@intro_init:

; 260  : 	{
; 261  : 		noiseData[i] = frand() - 0.5f;

	call	?frand@@YGMXZ				; frand
	fsub	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esi]
	add	esi, 4
	cmp	esi, OFFSET _noiseData+65536
	jl	SHORT $LL3@intro_init

; 262  : 	}
; 263  : #else
; 264  : 	for (int i = 0; i < NOISE_TEXTURE_SIZE * NOISE_TEXTURE_SIZE * NOISE_TEXTURE_SIZE * 4; i++)
; 265  : 	{
; 266  : 		noiseData[i] = (unsigned char)rand();
; 267  : 	}
; 268  : #endif
; 269  : 
; 270  : 	// Create and link shader and stuff:
; 271  : 	// I will have to separate these to be able to use more than one shader...
; 272  : 	// TODO: I should make some sort of compiling and linking loop...
; 273  : 	
; 274  : 	// init objects:	
; 275  : 	GLuint vMainObject = glCreateShader(GL_VERTEX_SHADER);

	push	35633					; 00008b31H
	call	DWORD PTR _glFP

; 276  : 	GLuint fMainBackground = glCreateShader(GL_FRAGMENT_SHADER);	

	mov	esi, 35632				; 00008b30H
	push	esi
	mov	edi, eax
	call	DWORD PTR _glFP

; 277  : 	GLuint fOffscreenCopy = glCreateShader(GL_FRAGMENT_SHADER);

	push	esi
	mov	ebx, eax
	call	DWORD PTR _glFP
	mov	esi, eax

; 278  : 	shaderPrograms[0] = glCreateProgram();

	call	DWORD PTR _glFP+4
	mov	DWORD PTR _shaderPrograms, eax

; 279  : 	shaderPrograms[1] = glCreateProgram();

	call	DWORD PTR _glFP+4

; 280  : 	// compile sources:
; 281  : 	glShaderSource(vMainObject, 1, &vertexMainObject, NULL);

	push	0
	push	OFFSET ?vertexMainObject@@3PBDB		; vertexMainObject
	push	1
	push	edi
	mov	DWORD PTR _shaderPrograms+4, eax
	call	DWORD PTR _glFP+8

; 282  : 	glCompileShader(vMainObject);

	push	edi
	call	DWORD PTR _glFP+12

; 283  : 	glShaderSource(fMainBackground, 1, &fragmentMainBackground, NULL);

	push	0
	push	OFFSET ?fragmentMainBackground@@3PBDB	; fragmentMainBackground
	push	1
	push	ebx
	call	DWORD PTR _glFP+8

; 284  : 	glCompileShader(fMainBackground);

	push	ebx
	call	DWORD PTR _glFP+12

; 285  : 	glShaderSource(fOffscreenCopy, 1, &fragmentOffscreenCopy, NULL);

	push	0
	push	OFFSET ?fragmentOffscreenCopy@@3PBDB	; fragmentOffscreenCopy
	push	1
	push	esi
	call	DWORD PTR _glFP+8

; 286  : 	glCompileShader(fOffscreenCopy);

	push	esi
	call	DWORD PTR _glFP+12

; 287  : 
; 288  : #ifdef SHADER_DEBUG
; 289  : 	// Check programs
; 290  : 	int tmp, tmp2;
; 291  : 	glGetShaderiv(vMainObject, GL_COMPILE_STATUS, &tmp);
; 292  : 	if (!tmp)
; 293  : 	{
; 294  : 		glGetShaderInfoLog(vMainObject, 4096, &tmp2, err);
; 295  : 		err[tmp2]=0;
; 296  : 		MessageBox(hWnd, err, "vMainObject shader error", MB_OK);
; 297  : 		return;
; 298  : 	}
; 299  : 	glGetShaderiv(fMainBackground, GL_COMPILE_STATUS, &tmp);
; 300  : 	if (!tmp)
; 301  : 	{
; 302  : 		glGetShaderInfoLog(fMainBackground, 4096, &tmp2, err);
; 303  : 		err[tmp2]=0;
; 304  : 		MessageBox(hWnd, err, "fMainBackground shader error", MB_OK);
; 305  : 		return;
; 306  : 	}
; 307  : 	glGetShaderiv(fOffscreenCopy, GL_COMPILE_STATUS, &tmp);
; 308  : 	if (!tmp)
; 309  : 	{
; 310  : 		glGetShaderInfoLog(fOffscreenCopy, 4096, &tmp2, err);
; 311  : 		err[tmp2]=0;
; 312  : 		MessageBox(hWnd, err, "fOffscreeCopy shader error", MB_OK);
; 313  : 		return;
; 314  : 	}
; 315  : #endif
; 316  : 
; 317  : 	// link shaders:
; 318  : 	glAttachShader(shaderPrograms[0], vMainObject);

	push	edi
	push	DWORD PTR _shaderPrograms
	call	DWORD PTR _glFP+16

; 319  : 	glAttachShader(shaderPrograms[0], fMainBackground);

	push	ebx
	push	DWORD PTR _shaderPrograms
	call	DWORD PTR _glFP+16

; 320  : 	glLinkProgram(shaderPrograms[0]);

	push	DWORD PTR _shaderPrograms
	call	DWORD PTR _glFP+20

; 321  : 	glAttachShader(shaderPrograms[1], vMainObject);

	push	edi
	push	DWORD PTR _shaderPrograms+4
	call	DWORD PTR _glFP+16

; 322  : 	glAttachShader(shaderPrograms[1], fOffscreenCopy);

	push	esi
	push	DWORD PTR _shaderPrograms+4
	call	DWORD PTR _glFP+16

; 323  : 	glLinkProgram(shaderPrograms[1]);

	push	DWORD PTR _shaderPrograms+4
	call	DWORD PTR _glFP+20

; 324  : 
; 325  : 	// Set texture.
; 326  : 	glEnable(GL_TEXTURE_3D); // automatic?

	mov	esi, 32879				; 0000806fH
	push	esi
	call	DWORD PTR __imp__glEnable@4

; 327  : 	glGenTextures(1, &noiseTexture);

	push	OFFSET _noiseTexture
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 328  : 	glBindTexture(GL_TEXTURE_3D, noiseTexture);

	push	DWORD PTR _noiseTexture
	push	esi
	call	DWORD PTR __imp__glBindTexture@8

; 329  : 	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	mov	edi, DWORD PTR __imp__glTexParameteri@12
	mov	ebx, 9729				; 00002601H
	push	ebx
	push	10241					; 00002801H
	push	esi
	call	edi

; 330  : 	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	push	ebx
	push	10240					; 00002800H
	push	esi
	call	edi

; 331  : 	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	mov	ebx, 10497				; 00002901H
	push	ebx
	push	10242					; 00002802H
	push	esi
	call	edi

; 332  : 	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_REPEAT);

	push	ebx
	push	10243					; 00002803H
	push	esi
	call	edi

; 333  : 	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_REPEAT);

	push	ebx
	push	32882					; 00008072H
	push	esi
	call	edi

; 334  : #ifdef FLOAT_TEXTURE
; 335  : 	glTexImage3D(GL_TEXTURE_3D, 0, GL_RGBA32F,
; 336  : 				 NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE,
; 337  : 				 0, GL_RGBA, GL_FLOAT, noiseData);

	push	OFFSET _noiseData
	push	5126					; 00001406H
	mov	ebx, 6408				; 00001908H
	push	ebx
	push	0
	push	16					; 00000010H
	push	16					; 00000010H
	push	16					; 00000010H
	push	34836					; 00008814H
	push	0
	push	esi
	call	DWORD PTR _glFP+28

; 338  : #else
; 339  : 	glTexImage3D(GL_TEXTURE_3D, 0, GL_RGBA8,
; 340  : 				 NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE,
; 341  : 				 0, GL_RGBA, GL_UNSIGNED_BYTE, noiseData);
; 342  : #endif
; 343  : 
; 344  : 	// Create a rendertarget texture
; 345  : 	glGenTextures(1, &offscreenTexture);

	push	OFFSET _offscreenTexture
	push	1
	call	DWORD PTR __imp__glGenTextures@8

; 346  : 	glBindTexture(GL_TEXTURE_2D, offscreenTexture);

	push	DWORD PTR _offscreenTexture
	mov	esi, 3553				; 00000de1H
	push	esi
	call	DWORD PTR __imp__glBindTexture@8

; 347  : 	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	fld	DWORD PTR __real@46180400
	mov	edi, DWORD PTR __imp__glTexParameterf@12
	push	ecx
	fstp	DWORD PTR [esp]
	push	10240					; 00002800H
	push	esi
	call	edi

; 348  : 	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	fld	DWORD PTR __real@46180400
	push	ecx
	fstp	DWORD PTR [esp]
	push	10241					; 00002801H
	push	esi
	call	edi

; 349  : 	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);

	fld	DWORD PTR __real@47012f00
	push	ecx
	fstp	DWORD PTR [esp]
	push	10242					; 00002802H
	push	esi
	call	edi

; 350  : 	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);	

	fld	DWORD PTR __real@47012f00
	push	ecx
	fstp	DWORD PTR [esp]
	push	10243					; 00002803H
	push	esi
	call	edi

; 351  : 	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT, 0,
; 352  : 		         GL_RGBA, GL_UNSIGNED_BYTE, 0);

	xor	eax, eax
	push	eax
	push	5121					; 00001401H
	push	ebx
	push	eax
	push	256					; 00000100H
	push	512					; 00000200H
	push	32856					; 00008058H
	push	eax
	push	esi
	call	DWORD PTR __imp__glTexImage2D@36
	pop	edi
	pop	esi
	pop	ebx

; 353  : 	//glBindTexture(GL_TEXTURE_2D, 0);
; 354  : }

	ret	0
?intro_init@@YGXXZ ENDP					; intro_init
_TEXT	ENDS
PUBLIC	__real@bf800000
PUBLIC	__real@3f800000
PUBLIC	__real@3f400000
PUBLIC	__real@3d000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3f80000000000000
PUBLIC	__real@40490e56
PUBLIC	__real@4f800000
PUBLIC	__real@3a83126f
PUBLIC	?intro_do@@YGXJ@Z				; intro_do
EXTRN	__imp__glCopyTexSubImage2D@32:PROC
EXTRN	__imp__glRectf@16:PROC
EXTRN	__imp__glViewport@16:PROC
EXTRN	__imp__glGetIntegerv@8:PROC
EXTRN	__imp__glLoadMatrixf@4:PROC
EXTRN	?outwave@@3PAY01NA:BYTE				; outwave
EXTRN	__imp__glMatrixMode@4:PROC
_BSS	SEGMENT
_parameterMatrix DD 010H DUP (?)
_BSS	ENDS
;	COMDAT __real@bf800000
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3d000000
CONST	SEGMENT
__real@3d000000 DD 03d000000r			; 0.03125
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f80000000000000
CONST	SEGMENT
__real@3f80000000000000 DQ 03f80000000000000r	; 0.0078125
CONST	ENDS
;	COMDAT __real@40490e56
CONST	SEGMENT
__real@40490e56 DD 040490e56r			; 3.1415
CONST	ENDS
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
; Function compile flags: /Ogsp
; File c:\users\joachim hofer\documents\mostlyharmless\mistymist_release3\i4k_ogl\src\intro.cpp
CONST	ENDS
;	COMDAT ?intro_do@@YGXJ@Z
_TEXT	SEGMENT
tv532 = -4						; size = 4
tv531 = -4						; size = 4
tv522 = -4						; size = 4
tv517 = -4						; size = 4
_itime$ = 8						; size = 4
?intro_do@@YGXJ@Z PROC					; intro_do, COMDAT

; 357  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 358  : 	//GLUquadric* quad = gluNewQuadric();
; 359  : 
; 360  : 	itime += SYNC_ADJUSTER;

	add	DWORD PTR _itime$[ebp], 80		; 00000050H

; 361  : 	float ftime = 0.001f*(float)itime;
; 362  : 
; 363  :     // render
; 364  :     glEnable( GL_CULL_FACE );

	push	2884					; 00000b44H
	call	DWORD PTR __imp__glEnable@4

; 365  : 
; 366  : 	glMatrixMode(GL_MODELVIEW);

	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4

; 367  : 	parameterMatrix[0] = ftime; // time	

	fild	DWORD PTR _itime$[ebp]

; 368  : 	/* shader parameters */
; 369  : 	int scene = 0;
; 370  : 	unsigned int sceneTime = (unsigned int)itime;

	mov	edx, DWORD PTR _itime$[ebp]

; 371  : 	while (sceneTime > (unsigned int)sceneLength[scene] * SYNC_MULTIPLIER)

	movzx	ecx, BYTE PTR _sceneLength
	fmul	DWORD PTR __real@3a83126f
	xor	eax, eax
	fstp	DWORD PTR _parameterMatrix
	jmp	SHORT $LN29@intro_do
$LL8@intro_do:

; 372  : 	{
; 373  : 		sceneTime -= (unsigned int)sceneLength[scene]*SYNC_MULTIPLIER;

	sub	edx, ecx
	movzx	ecx, BYTE PTR _sceneLength[eax+1]

; 374  : 		scene++;		

	inc	eax
$LN29@intro_do:

; 371  : 	while (sceneTime > (unsigned int)sceneLength[scene] * SYNC_MULTIPLIER)

	imul	ecx, 361				; 00000169H
	cmp	edx, ecx
	ja	SHORT $LL8@intro_do

; 375  : 	}
; 376  : 	float t = (float)(sceneTime) /
; 377  : 		      (float)(sceneLength[scene] * SYNC_MULTIPLIER);
; 378  : 	t = 0.5f - 0.5f * (float)cos(t*3.1415f);

	mov	DWORD PTR tv532[ebp], edx
	fild	DWORD PTR tv532[ebp]
	test	edx, edx
	jns	SHORT $LN27@intro_do
	fadd	DWORD PTR __real@4f800000
$LN27@intro_do:
	movzx	ecx, BYTE PTR _sceneLength[eax]
	imul	ecx, 361				; 00000169H

; 379  : 	for (int k = 0; k < NUM_PARAMETERS; k++)

	imul	eax, 9
	mov	DWORD PTR tv531[ebp], ecx

; 380  : 	{
; 381  : 		float a = (float)(sceneData[scene][k] * (1./128.)) +
; 382  : 			      t * (float)(sceneDelta[scene][k] * (1./128.));
; 383  : 		parameterMatrix[k+1] = a;

	mov	ecx, OFFSET _parameterMatrix+4
	fidiv	DWORD PTR tv531[ebp]
	fmul	DWORD PTR __real@40490e56
	fcos
	fld	DWORD PTR __real@3f000000
	fmul	ST(1), ST(0)
	fsubrp	ST(1), ST(0)
	fld	QWORD PTR __real@3f80000000000000
$LN6@intro_do:
	movsx	edx, BYTE PTR _sceneDelta[eax]
	mov	DWORD PTR tv522[ebp], edx
	movzx	edx, BYTE PTR _sceneData[eax]
	fild	DWORD PTR tv522[ebp]
	mov	DWORD PTR tv517[ebp], edx
	inc	eax
	fmul	ST(0), ST(1)
	fmul	ST(0), ST(2)
	fild	DWORD PTR tv517[ebp]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	cmp	ecx, OFFSET _parameterMatrix+40
	jl	SHORT $LN6@intro_do

; 384  : 	}
; 385  : 
; 386  : 	// get music information
; 387  : 	double loudness = 1.0;
; 388  : 	int musicPos = (((itime-SYNC_ADJUSTER)*441)/10);

	mov	eax, DWORD PTR _itime$[ebp]
	fstp	ST(0)
	add	eax, -80				; ffffffb0H
	fstp	ST(0)
	imul	eax, 441				; 000001b9H
	fld1
	cdq
	push	10					; 0000000aH
	pop	ecx
	idiv	ecx
	mov	ecx, 4096				; 00001000H
	shl	eax, 4
	add	eax, OFFSET ?outwave@@3PAY01NA		; outwave
$LN3@intro_do:

; 389  : 	for (int k = 0; k < 4096; k++)
; 390  : 	{
; 391  : 		loudness += outwave[musicPos][k]*outwave[musicPos][k];

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	ecx
	fld	ST(0)
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LN3@intro_do

; 392  : 	}
; 393  : #ifdef USEDSOUND
; 394  : 	parameterMatrix[4] += (float)log(loudness) * (1.f/32.f) - .75f; // This makes it silent?

	fldln2
	push	ebx
	fxch	ST(1)
	push	esi
	push	edi

; 395  : 	//parameterMatrix[4] = (float)log(loudness) * 0.1f - 0.5f;
; 396  : #endif
; 397  : 
; 398  : 	glLoadMatrixf(parameterMatrix);

	push	OFFSET _parameterMatrix
	fyl2x
	fmul	DWORD PTR __real@3d000000
	fsub	DWORD PTR __real@3f400000
	fadd	DWORD PTR _parameterMatrix+16
	fstp	DWORD PTR _parameterMatrix+16
	call	DWORD PTR __imp__glLoadMatrixf@4

; 399  : 
; 400  : 	// draw offscreen
; 401  : 	glGetIntegerv(GL_VIEWPORT, viewport);

	push	OFFSET ?viewport@@3PAHA			; viewport
	push	2978					; 00000ba2H
	call	DWORD PTR __imp__glGetIntegerv@8

; 402  : 	glViewport(0, 0, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT);

	mov	ebx, DWORD PTR __imp__glViewport@16
	push	256					; 00000100H
	push	512					; 00000200H
	push	0
	push	0
	call	ebx

; 403  : 	glBindTexture(GL_TEXTURE_3D, offscreenTexture);

	push	DWORD PTR _offscreenTexture
	mov	esi, DWORD PTR __imp__glBindTexture@8
	mov	edi, 32879				; 0000806fH
	push	edi
	call	esi

; 404  : 	glUseProgram(shaderPrograms[0]);

	push	DWORD PTR _shaderPrograms
	call	DWORD PTR _glFP+24

; 405  : 	glBindTexture(GL_TEXTURE_3D, noiseTexture);

	push	DWORD PTR _noiseTexture
	push	edi
	call	esi

; 406  : 	//gluSphere(quad, 2.0f, 8, 8);
; 407  : 	glRectf(-1.0, -1.0, 1.0, 1.0);

	fld1
	sub	esp, 16					; 00000010H
	fst	DWORD PTR [esp+12]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR __real@bf800000
	fst	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glRectf@16

; 408  : 
; 409  : 	// copy to front
; 410  : 	glViewport(0, 0, viewport[2], viewport[3]);

	push	DWORD PTR ?viewport@@3PAHA+12
	push	DWORD PTR ?viewport@@3PAHA+8
	push	0
	push	0
	call	ebx

; 411  : 	glBindTexture(GL_TEXTURE_3D, offscreenTexture);

	push	DWORD PTR _offscreenTexture
	push	edi
	call	esi

; 412  : 	glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT);   //Copy back buffer to texture

	push	256					; 00000100H
	push	512					; 00000200H
	xor	eax, eax
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	push	3553					; 00000de1H
	call	DWORD PTR __imp__glCopyTexSubImage2D@32

; 413  : 	glUseProgram(shaderPrograms[1]);	

	push	DWORD PTR _shaderPrograms+4
	call	DWORD PTR _glFP+24

; 414  : 	//gluSphere(quad, 2.0f, 8, 8);
; 415  : 	glRectf(-1.0, -1.0, 1.0, 1.0);

	fld1
	sub	esp, 16					; 00000010H
	fst	DWORD PTR [esp+12]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR __real@bf800000
	fst	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glRectf@16
	pop	edi
	pop	esi
	pop	ebx

; 416  : }

	leave
	ret	4
?intro_do@@YGXJ@Z ENDP					; intro_do
_TEXT	ENDS
END
