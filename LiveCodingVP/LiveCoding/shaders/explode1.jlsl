vec4 innerColor = vec4(0.31, 1.0, 1.0, 1.0);                          
vec4 outerColor = vec4(1.0, 0.34, 0.03, 1.0);                         
vec4 bgColor1 = vec4(0.098, 0.14, 0.256, 1.0);                        
vec4 bgColor2 = vec4(0.0, 0.0, 0.0, 0.0);                             
vec4 fogColor = vec4(0.0, 0.45, 0.75, 1.0);                           
                                                                      
vec3 color3D(vec3 pos, vec3 noiseStuff) {                             
float dist = length(pos);                                             
float color = smoothstep(0.3, 1.2, dist);                             
float brightness = 1.0 - smoothstep(0.5, 2.0, dist);                  
float stuffi = noiseStuff.g * noiseStuff.b;                           
                                                                      
return brightness*stuffi*vec3(2.) + mix(vec3(innerColor),             
vec3(outerColor), color) * brightness;                                
}                                                                     
      
void main(void) {                                                     
vec3 tvNoise = noise8(vec3(ppos, 1.0)*0.05 +                         
vec3(0.,0.,time*0.01), 0.65).xyz;     
                                                                      
vec3 rayDir = normalize(vec3(ppos, 1.0) * vec3(1.0, 0.6, 1.0));       
vec3 camPos = vec3(-0.7, 1.0, -4.0);            
                                                                      
// rotate camera around y axis;                                       
camPos.yz = rotate(camPos.yz, -0.2);                                  
rayDir.yz = rotate(rayDir.yz, -0.2);                                  
camPos.xz = rotate(camPos.xz, time * 0.3);                            
rayDir.xz = rotate(rayDir.xz, time * 0.3);                            
                                                                      
vec3 rayPos = camPos;                                                 
float sceneSize = 10.0;                                               
vec3 totalColor = vec3(0.);                                           
float stepSize;                                                       
float totalDensity = 0.0;                                             
                                                                      
float moveOut = sin(time*0.4);                                        
float moveStart = 0.5 - 0.499*sin(time*0.4 + 2.1);                    
float visibleOut = 0.5 - 0.499*cos(time*0.4);                         
//float moveOut = 2.0 * (spike * 0.7 * knob1 + 0.7 * slider1) - 1.0;  
//float moveStart = 1.0 - (spike * 0.7 * knob1 + 0.7 * slider2);      
//float visibleOut = (spike * 0.7 * knob1 + 0.7 * slider3);           
                                                                      
for (int i = 0; i < 100 && length(rayPos)<sceneSize &&                
totalDensity < 0.95; i++) {                                           
vec3 tmpPos = rayPos;                                                 
                                                                      
vec3 noiseData = noise3(tmpPos*0.02+                                 
vec3(0.0, time*0.017, 0.0), slider4).xyz + slider5;    
float firstNoise = noiseData.r;                                       
firstNoise = clamp(0.4 - abs(firstNoise), 0.0, 0.4);                  
                                                                      
vec3 noiseData2 = 2.*(firstNoise+0.2) *                               
noise3(noiseData*slider6 + rayPos*0.11 -
vec3(0.0, time*0.017, 0.0), 0.7).xyz;
float noiseVal = noiseData2.r * 0.5;                                  
                                                                      
tmpPos += 3.*noiseData;                                               
                                                                      
// base head;                                                         
float sphere = abs(length(tmpPos)-0.9) - 1.1 +                        
1.2*pow(moveStart,0.1) - 0.5*firstNoise;                              
float sphere2 = abs(length(tmpPos) - 3.1 -                            
3.*moveOut - 3.*(moveOut+1.)*firstNoise) +                            
visibleOut - 1.2*firstNoise;                                          
float sphere3 = abs(length(tmpPos) - 2.1 -                            
1.5*moveOut - 1.*(moveOut+1.)*firstNoise) +                           
visibleOut - 1.2*firstNoise;                                          
                                                                      
float implicitVal;                                                    
                                                                      
float outer = min(sphere2, sphere3);                                  
outer = max(outer, min(outer, 0.) + 3.*noiseVal);                     
                                                                      
implicitVal = min(sphere, outer);                                     
                                                                      
totalColor += (1./150.) * vec3(fogColor) * (1.-totalDensity);         
totalDensity += 1./150.;                                              
if (implicitVal < 0.0) {                                              
float localDensity = clamp(0.0 -                                      
max(0.2-3.*abs(noiseVal),0.05)*implicitVal, 0.0, 1.0);                
totalColor = totalColor + (1.-totalDensity) *                         
color3D(rayPos*0.4, noiseData2) * localDensity;                       
totalDensity = totalDensity + (1.-totalDensity) * localDensity;       
}                                                                     
                                                                      
stepSize = (implicitVal) * 0.25;                                      
stepSize = max(0.03, stepSize);                                       
rayPos += rayDir * stepSize;                                          
}                                                                     
                                                                      
float grad = normalize(rayPos).y;                                     
totalColor += (grad * vec3(bgColor1) + (1.-grad)*vec3(bgColor2));     
                                                                      
gl_FragColor = vec4(totalColor, 1.0);                                 
}                                                                     
                                                                      
