/* File generated with Shader Minifier 1.1.1
 * http://www.ctrl-alt-test.fr
 */
#ifndef SHADER_CODE_H_
# define SHADER_CODE_H_
# define V_M "v"
# define V_V "z"

const char shader_txt[] = ""
 "varying vec3 z;"
 "varying mat4 v;"
 "vec4 n(vec4 v)"
 "{"
   "return fract((v.zxwy+vec4(.735,.369,.438,.921))*vec4(9437.4,7213.5,5935.72,4951.6));"
 "}"
 "vec4 n(vec4 v,vec4 s)"
 "{"
   "return vec4(v.x*s.x-dot(v.yzw,s.yzw),v.x*s.yzw+s.x*v.yzw+cross(v.yzw,s.yzw));"
 "}"
 "mat3 s(vec4 v)"
 "{"
   "vec4 s=v.x*v,c=v.y*v,z=v.z*v;"
   "return mat3(1.)-2.*mat3(c.y+z.z,z.w-s.y,-s.z-c.w,-s.y-z.w,s.x+z.z,s.w-c.z,c.w-s.z,-c.z-s.w,s.x+c.y);"
 "}"
 "float m(vec3 v)"
 "{"
   "v=v.xzy*5.;"
   "vec3 s=v*v;"
   "float z=s.x+2.25*s.y+s.z-1.,c=s.x*s.z*v.z+.08888*s.y*s.z*v.z;"
   "return z*z*z-c;"
 "}"
 "void main()"
 "{"
   "vec4 c=v[1];"
   "vec3 f=normalize(z*vec3(1.,.6,1.)),l=vec3(0.,0.,-v[0][1]);"
   "float i=v[0][2]*4.5;"
   "l.xz=vec2(cos(i)*l.x-sin(i)*l.z,sin(i)*l.x+cos(i)*l.z);"
   "f.xz=vec2(cos(i)*f.x-sin(i)*f.z,sin(i)*f.x+cos(i)*f.z);"
   "vec3 x=l;"
   "float r=8.;"
   "vec3 w=vec3(0.);"
   "float y,e=0.,a=0.;"
   "for(int g=0;length(x)<r&&e<.9&&g<50;g++)"
     "{"
       "float b;"
       "vec4 t=normalize(vec4(cos(v[0][3]),sin(v[0][3]),sin(v[0][3]*1.3),sin(v[0][3]*2.7)));"
       "float o=1.;"
       "vec3 d=vec3(0.),h=vec3(1.,.4,.2);"
       "if(v[1][2]<.5)"
         "{"
           "b=1e+10;"
           "for(int u=0;u<12;u++)"
             "{"
               "vec4 k;"
               "float p;"
               "vec3 F,C;"
               "mat3 Z=s(t);"
               "vec4 Y=c;"
               "for(int X=0;X<4;X++)"
                 "{"
                   "Y=n(Y);"
                   "vec3 W=o*(Y.xyz*Y.xyz*Y.xyz*Y.xyz*vec3(.2)+vec3(.05));"
                   "b=min(b,length(max(abs((x-(.5*Y.wzx-vec3(.25))*Z*o-d)*s(n(normalize(Y-vec4(.5)),t)))-W,0.))-length(W)*.3);"
                 "}"
               "float W=1e+10;"
               "for(int X=0;X<2;X++)"
                 "{"
                   "Y=n(Y);"
                   "vec4 V=n(normalize(Y-vec4(.5)),t);"
                   "float U=o*(Y.x*.3+.25);"
                   "vec3 T=(.5*Y.wzx-vec3(.25))*Z*o+d;"
                   "float S=length(x-T)-U;"
                   "if(S<W)"
                     "W=S,k=V,p=U,F=T,C=Y.xyz;"
                 "}"
               "if(W>b)"
                 "{"
                   "break;"
                 "}"
               "else"
                 " t=k,o=p,d=F,h=.5*h+.5*C;"
             "}"
         "}"
       "else"
         "{"
           "float Y=.01,W=m(x);"
           "vec3 X=1./Y*(vec3(m(x+vec3(Y,0.,0.)),m(x+vec3(0.,Y,0.)),m(x+vec3(0.,0.,Y)))-vec3(W));"
           "b=W/(length(X)+Y);"
           "h=vec3(1.,.2,.2);"
         "}"
       "w+=vec3(.02,1./70.,1./90.)*3.06/exp(abs(b*5.))*v[3][3];"
       "e+=1./15./exp(abs(b*10.)+.5);"
       "a+=abs(b)*.99;"
       "if(b<0.)"
         "w=w+(1.-e)*h,e=1.f;"
       "y=max(.005*a,abs(b)*.99);"
       "x+=f*y;"
     "}"
   "float Y=normalize(f).y;"
   "w+=(1.-e)*(Y*vec3(0.,-.4,-.3)+(1.-Y)*vec3(0.,.4,.6));"
   "gl_FragColor=vec4(w-vec3(0.),1.);"
 "}";

#endif // SHADER_CODE_H_
